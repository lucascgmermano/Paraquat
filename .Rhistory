"pramato",
"quatdown",
"sprayquat",
"tocha"
)
`%~in%` <- function(x, table, method = "lv", maxDist = 2) {
!is.na(amatch(x, table, method = method, maxDist = maxDist))
}
df_filtrado <- df_ini %>%
filter(
if_any(
c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ (.x %in% nome_produto) | (.x %~in% nome_produto)
)
)
View(df_filtrado)
df_ini %>% filter(if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")), ~ .x %in% nome_produto) | if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")), ~ .x %~in% nome_produto)) %>% View
`%~in%` <- function(x, table, method = "lv", maxDist = 1) {
!is.na(amatch(x, table, method = method, maxDist = maxDist))
}
df_filtrado <- df_ini %>%
filter(
if_any(
c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ (.x %in% nome_produto) | (.x %~in% nome_produto)
)
)
View(df_filtrado)
View(df_filtrado[cols_alvo])
df_ini[cols_alvo] %>%
df_ini[cols_alvo] %>%
filter(if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ .x %in% nome_produto))
df_ini[cols_alvo] %>%
filter(if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ .x %in% nome_produto))
stringi::stri_trans_general(str = df_ini$AGENTE_1, "Latin-ASCII")
lapply(df_ini[cols_alvo], stringi::stri_trans_general)
lapply(df_ini[cols_alvo], stringi::stri_trans_general("Latin-ASCII"))
lapply(df_ini[cols_alvo], stringi::stri_trans_general(id = x,"Latin-ASCII"))
lapply(df_ini[cols_alvo], stringi::stri_trans_general(id = df_ini[cols_alvo],"Latin-ASCII"))
lapply(df_ini[cols_alvo], stringi::stri_trans_general(str = df_ini[cols_alvo],"Latin-ASCII"))
lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
df_ini[cols_alvo]
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
# Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x
),
stringsAsFactors = FALSE
)
# Seleciona apenas as colunas sobre agentes
df_ini <- df_ini %>% select(starts_with("AGENTE"), starts_with("P_ATIVO"))
df_ini
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
# Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x
),
stringsAsFactors = FALSE
)
# Seleciona apenas as colunas sobre agentes
cols_alvo <- df_ini %>% select(starts_with("AGENTE"), starts_with("P_ATIVO"))
cols_alvo
# Os dados ja estao sem acento e caracteres especiais, entao somente tornar para letra minuscula
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
df_ini[cols_alvo]
cols_alvo
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
# Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x
),
stringsAsFactors = FALSE
)
# Seleciona apenas nomes das colunas sobre agentes
cols_alvo <- grep("^(AGENTE|P_ATIVO)", names(df_ini), value = TRUE, ignore.case = TRUE)
# Os dados ja estao sem acento e caracteres especiais, entao somente tornar para letra minuscula
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
df_ini[cols_alvo]
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
lapply(df_ini[cols_alvo] , stringr::str_trim)
df_ini[cols_alvo]
## Remover espacial de inicio e final
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo] , stringr::str_trim)
df_ini[cols_alvo] %>% View()
## Substitui multiplos espacos por apenas um
lapply(df_ini[cols_alvo], stringr::str_squish)
## Substitui multiplos espacos por apenas um
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_squish)
df_ini[cols_alvo] %>% View()
nome_produto <- c("c12h14n2",
"bipiridínio",
"bipyridinium",
"flak 200",
"gramocil",
"gramoking",
"gramoking",
"gramoxone",
"gramoxone 200",
"helmoxone",
"laredo",
"nuquat",
"orbit",
"paradox",
"paraquat",
"paraquat 200 sl",
"paraquate",
"paraquate alta 200 sl",
"pramato",
"quatdown",
"sprayquat",
"tocha"
)
library(foreign)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(stringdist)
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
# Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x
),
stringsAsFactors = FALSE
)
# Seleciona apenas nomes das colunas sobre agentes
cols_alvo <- grep("^(AGENTE|P_ATIVO)", names(df_ini), value = TRUE, ignore.case = TRUE)
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
## Remover caracteres especiais e acentos
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
## Remover espacial de inicio e final
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo] , stringr::str_trim)
## Substitui multiplos espacos por apenas um
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_squish)
nome_produto <- c("c12h14n2",
"bipiridínio",
"bipyridinium",
"flak 200",
"gramocil",
"gramoking",
"gramoking",
"gramoxone",
"gramoxone 200",
"helmoxone",
"laredo",
"nuquat",
"orbit",
"paradox",
"paraquat",
"paraquat 200 sl",
"paraquate",
"paraquate alta 200 sl",
"pramato",
"quatdown",
"sprayquat",
"tocha"
)
`%~in%` <- function(x, table, method = "lv", maxDist = 1) {
!is.na(amatch(x, table, method = method, maxDist = maxDist))
}
df_filtrado <- df_ini %>%
filter(
if_any(
c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ (.x %in% nome_produto) | (.x %~in% nome_produto)
)
)
View(df_filtrado[cols_alvo])
df_ini[cols_alvo] %>%
filter(if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ .x %in% nome_produto)) %>% View()
### Funcao para detectar semelhancas com distância de Levenshtein
`%~in%` <- function(x, table, method = "lv", maxDist = 2) {
!is.na(amatch(x, table, method = method, maxDist = maxDist))
}
df_filtrado <- df_ini %>%
filter(
if_any(
c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ (.x %in% nome_produto) | (.x %~in% nome_produto)
)
)
View(df_filtrado[cols_alvo])
### Funcao para detectar semelhancas com distância de Levenshtein
`%~in%` <- function(x, table, method = "lv", maxDist = 1) {
!is.na(amatch(x, table, method = method, maxDist = maxDist))
}
df_filtrado <- df_ini %>%
filter(
if_any(
c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ (.x %in% nome_produto) | (.x %~in% nome_produto)
)
)
View(df_filtrado[cols_alvo])
table(df_filtrado)
table(df_filtrado$AGENTE_1)
## Filtro Simples
df_filtrado_simples <- df_ini[cols_alvo] %>%
filter(if_any(c(starts_with("AGENTE"), starts_with("P_ATIVO")),
~ .x %in% nome_produto))
View(df_filtrado_simples)
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
library(foreign)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(stringi)
library(stringdist)
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
## Seleciona apenas nomes das colunas de interesse
cols_alvo <- grep("^(AGENTE|P_ATIVO)", names(df_ini), value = TRUE, ignore.case = TRUE)
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
## Remover caracteres especiais e acentos
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
## Remover espacial de inicio e final
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo] , stringr::str_trim)
## Substitui multiplos espacos por apenas um
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_squish)
## Substitui de caracteres de pontuação
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
str_replace_all(x, "[-_/]", " ")
})
nome_produto <- unique(tolower(c(
# nomes e variações corretos
"paraquat", "gramoxone", "gramocil", "flak 200", "helmoxone", "laredo",
"nuquat", "orbit", "paradox", "pramato", "quatdown", "sprayquat", "tocha",
# -- erros e variações observadas
"paroquat","paraquato","paraquatu","paracoate","parocoate","paroquate",
"paraquate","paraquante","paraquant","parakuat","paracuat","paraquat 200",
"paraquat sl","para quat","paraquatium","gramaxone","gramachone","gramoxin",
"gramoxona","gramucil","granucil","gramuciu","gromaxone","gramonone",
"granoxine","gromocil","gramozone","gramocile","gramociel","gramecil",
"granocil","gramexil","gramokil","gromaxon","gramozoni",
"herbicida paraquat","herbicida gramoxone","herbicida gramocil",
"agrotoxico paraquat", "veneno paraquat", "veneno paraquate",
# --erros gerados por algoritmo (plausiveis e realistas) ---
# omissões e transposições simples
"paraqut", "paraquar", "paraqaut", "parauat", "parquat",
# trocas fonéticas / consoantes próximas
"parakwat", "paraqwat", "parakuat", "parakuat", "paracuat",
# pequenos erros de digitacao
"paraquatd", "paraquatt", "paraqvat",
# omissão de letra interna
"paraqua", "paraqu",
# gramoxone/gramocil foneticos
"gramozon", "gramoxon", "gramoxoni", "gramocill", "gramociel", "gramocill",
"gromaxon", "gromoxone", "gramon", "gramocie", "gramokson"
)))
i = iris
i
i[1]
rm(i)
lista_arquivos <- list()
lista_arquivos
lista_arquivos <-
teste <- list()
teste[[1]] <- iris
teste[[1]] <- iris
teste[[1]]
teste[[2]] <- iris3
teste[]
teste[[2]]
lista_arquivos <- list()
n <- 1
list.files()
list.files(path = "Dados_brutos/")
list.files(path = "Dados_brutos/")[]
list.files(path = "Dados_brutos/")[1]
name(list.files(path = "Dados_brutos/"))
names(list.files(path = "Dados_brutos/"))
list.files(path = "Dados_brutos/")[[i]]
list.files(path = "Dados_brutos/")[[2]]
library(foreign)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(stringi)
library(stringdist)
arquivos <- list.files(path = "Dados_brutos",
pattern = "\\.dbf$",
ignore.case = TRUE)
arquivos
processa_arquivo <- function(arquivo){
processa_arquivo <- function(arquivo){
df_ini <- read.dbf("Dados_brutos/i")
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
## Seleciona apenas nomes das colunas de interesse
cols_alvo <- grep("^(AGENTE|P_ATIVO)", names(df_ini), value = TRUE, ignore.case = TRUE)
# Normalizacao dos dados --------------------------------------------------
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
## Remover caracteres especiais e acentos
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
## Remover espacial de inicio e final
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo] , stringr::str_trim)
## Substitui multiplos espacos por apenas um
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_squish)
## Substitui de caracteres de pontuação
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
str_replace_all(x, "[-_/]", " ")
})
# Nomes comerciais --------------------------------------------------------
nome_produto <- unique(tolower(c(
# nomes e variações corretos
"paraquat", "gramoxone", "gramocil", "flak 200", "helmoxone", "laredo",
"nuquat", "orbit", "paradox", "pramato", "quatdown", "sprayquat", "tocha",
# -- erros e variações observadas
"paroquat","paraquato","paraquatu","paracoate","parocoate","paroquate",
"paraquate","paraquante","paraquant","parakuat","paracuat","paraquat 200",
"paraquat sl","para quat","paraquatium","gramaxone","gramachone","gramoxin",
"gramoxona","gramucil","granucil","gramuciu","gromaxone","gramonone",
"granoxine","gromocil","gramozone","gramocile","gramociel","gramecil",
"granocil","gramexil","gramokil","gromaxon","gramozoni",
"herbicida paraquat","herbicida gramoxone","herbicida gramocil",
"agrotoxico paraquat", "veneno paraquat", "veneno paraquate",
# --erros gerados por algoritmo (plausiveis e realistas) ---
# omissões e transposições simples
"paraqut", "paraquar", "paraqaut", "parauat", "parquat",
# trocas fonéticas / consoantes próximas
"parakwat", "paraqwat", "parakuat", "parakuat", "paracuat",
# pequenos erros de digitacao
"paraquatd", "paraquatt", "paraqvat",
# omissão de letra interna
"paraqua", "paraqu",
# gramoxone/gramocil foneticos
"gramozon", "gramoxon", "gramoxoni", "gramocill", "gramociel", "gramocill",
"gromaxon", "gromoxone", "gramon", "gramocie", "gramokson"
)))
# FILTRO ------------------------------------------------------------------
## Filtro
## Filtro definitivo
df_filtrado <- df_ini %>%
filter(
if_any(
starts_with("AGENTE"),
~ (.x %in% nome_produto) |
(stringr::str_detect(.x,
stringr::regex(paste0("\\b(", paste(nome_produto, collapse="|"), ")\\b"), ignore_case=TRUE)))
)
)
}
processa_arquivo <- function(arquivo){
df_ini <- read.dbf("Dados_brutos/i")
## Converter todo o dataframe para utf8
df_ini <- as.data.frame(
lapply(df_ini, \(x)
if (is.character(x) || is.factor(x))
stri_enc_toutf8(as.character(x))
else
x), stringsAsFactors = FALSE)
## Seleciona apenas nomes das colunas de interesse
cols_alvo <- grep("^(AGENTE|P_ATIVO)", names(df_ini), value = TRUE, ignore.case = TRUE)
# Normalizacao dos dados --------------------------------------------------
## Letra minuscula
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_to_lower)
## Remover caracteres especiais e acentos
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
stringi::stri_trans_general(str = x, id = "Latin-ASCII")
})
## Remover espacial de inicio e final
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo] , stringr::str_trim)
## Substitui multiplos espacos por apenas um
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], stringr::str_squish)
## Substitui de caracteres de pontuação
df_ini[cols_alvo] <- lapply(df_ini[cols_alvo], function(x) {
str_replace_all(x, "[-_/]", " ")
})
# Nomes comerciais --------------------------------------------------------
nome_produto <- unique(tolower(c(
# nomes e variações corretos
"paraquat", "gramoxone", "gramocil", "flak 200", "helmoxone", "laredo",
"nuquat", "orbit", "paradox", "pramato", "quatdown", "sprayquat", "tocha",
# -- erros e variações observadas
"paroquat","paraquato","paraquatu","paracoate","parocoate","paroquate",
"paraquate","paraquante","paraquant","parakuat","paracuat","paraquat 200",
"paraquat sl","para quat","paraquatium","gramaxone","gramachone","gramoxin",
"gramoxona","gramucil","granucil","gramuciu","gromaxone","gramonone",
"granoxine","gromocil","gramozone","gramocile","gramociel","gramecil",
"granocil","gramexil","gramokil","gromaxon","gramozoni",
"herbicida paraquat","herbicida gramoxone","herbicida gramocil",
"agrotoxico paraquat", "veneno paraquat", "veneno paraquate",
# --erros gerados por algoritmo (plausiveis e realistas) ---
# omissões e transposições simples
"paraqut", "paraquar", "paraqaut", "parauat", "parquat",
# trocas fonéticas / consoantes próximas
"parakwat", "paraqwat", "parakuat", "parakuat", "paracuat",
# pequenos erros de digitacao
"paraquatd", "paraquatt", "paraqvat",
# omissão de letra interna
"paraqua", "paraqu",
# gramoxone/gramocil foneticos
"gramozon", "gramoxon", "gramoxoni", "gramocill", "gramociel", "gramocill",
"gromaxon", "gromoxone", "gramon", "gramocie", "gramokson"
)))
# FILTRO ------------------------------------------------------------------
## Filtro
## Filtro definitivo
df_filtrado <- df_ini %>%
filter(
if_any(
starts_with("AGENTE"),
~ (.x %in% nome_produto) |
(stringr::str_detect(.x,
stringr::regex(paste0("\\b(", paste(nome_produto, collapse="|"), ")\\b"), ignore_case=TRUE)))
)
)
}
lista_arquivos <- lapply(arquivos, processa_arquivo)
source("~/Documentos/Paraquat/Trat_Geral.R")
source("~/Documentos/Paraquat/Trat_Geral.R")
source("~/Documentos/Paraquat/Trat_Geral.R")
df_ini <- read.dbf("Dados_brutos/IEXOBR11.dbf")
lista_arquivos
colnames(df_ini)
View(df_ini)
df_ini %>% select("DT_NOTIFIC", "SEM_NOT",  "NU_ANO", "SG_UF_NOT",
"ID_MUNICIP", "ID_REGIONA", "ID_UNIDADE", "DT_SIN_PRI",
"SEM_PRI", "ANO_NASC",  "NU_IDADE_N", "CS_SEXO",
"CS_GESTANT", "CS_RACA", "CS_ESCOL_N", "SG_UF",
"ID_MN_RESI", "ID_RG_RESI", "ID_PAIS",  "DT_INVEST",
"ID_OCUPA_N", "SIT_TRAB",   "LOC_EXPO",   "CNAE","UF_EMP",
"MUN_EMP",  "PAIS_EXP", "AGENTE_TOX", "COAGTOXMA1",
"COAGTOXMA2", "COAGTOXMA3", "AGENTE_1", "AGENTE_2",
"AGENTE_3", "P_ATIVO_1", "P_ATIVO_2", "P_ATIVO_3",
"UTILIZACAO", "ATIVIDA_1",  "ATIVIDA_2",  "ATIVIDA_3",
"VIA_1", "VIA_2", "VIA_3", "CIRCUNSTAN", "DOENCA_TRA",
"TPEXP",  "NUTEMPO",  "TPTEMPO",  "TPATENDE", "HOSPITAL",
"DTINTERNA", "UF_HOSP", "MUN_HOSP", "CLASSI_FIN",
"DIAG_CONF",  "CRITERIO", "EVOLUCAO", "DT_OBITO", "CAT",
"DT_ENCERRA", "DT_DIGITA",  "DT_TRANSUS", "DT_TRANSDM",
"TRAB_DESC", "LOC_EXP_DE", "OUT_AGENTE", "UTIL_DESC",
"LAVOURA",  "CIRCUN_DES")
source("~/Documentos/Paraquat/Trat_Geral.R")
df_todos %>% group_by(AGENTE_TOX) %>%
count()
saveRDS(object = df_todos,
file = "df_todos.rds")
df_todos <- readRDS("~/Documentos/Paraquat/df_todos.rds")
df_todos <- readRDS("~/Documentos/Paraquat/df_todos.rds")
